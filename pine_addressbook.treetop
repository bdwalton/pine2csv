grammar PineAddressbook
        rule addressbook
             car:addressentry cdr:addressentry* eof {
	     def to_csv
	     	 car.to_csv + "\n" + '-' * 50 + "\n" +
		 cdr.elements.map do |ae|
		 ae.to_csv
		 end.join("\n" + '-' * 50 + "\n")
	     end
	     }
        end

        rule addressentry
             nick fieldsep pinename fieldsep recipient optionals? eol {
	     def to_csv	   
	     [:nick, :pinename, :recipient].map do |token|
	     	     self.send(token).to_s
	     end.join(', ')
	     end
	     }
        end

	rule optionals
	     fieldsep fcc (fieldsep entrycomment)?
	end

	rule fieldsep
	     continuation? "\t" continuation?
	end

	rule continuation
	     eol padding
	end

	rule padding
	     "   "
	end

	rule nick
	     (!fieldsep .)* {
	     def to_s; text_value; end
	     }
	end

	rule pinename
	     qpname / bpname
	end

	rule recipient
	     personlist / person
	end

	rule personlist
	     lstart continuation? car:person cdr:(plistsep person)* continuation? lend {
	     	    def to_s
		    	['group', car.to_s, cdr.elements.map do |p|
			   p.person.to_s
			end.flatten].join(', ')
		    end
	     }

	end

	rule lstart
	     '('
	end

	rule lend
	     ')'
	end

	rule person
	     qualified_address / emailaddress
	end

	rule qualified_address
	     recipname [\s]+ '<' emailaddress '>' {
	     def to_s
	     	 "\"#{recipname.to_s}\" <#{emailaddress.to_s}>"
	     end
	     }
	end


	rule plistsep
	     continuation? [\s]* [,] [\s]* continuation?
	end

	rule recipname
	     dqrname / sqrname / brname
	end

	rule dqrname
	     dq n:(!dq !eol . / dq dq)* dq {
	     def to_s; n.text_value; end
	     }
	end

	rule sqrname
	     sq (!sq !eol . / sq sq)* sq {
	     def to_s; n.text_value; end
	     }
	end

	rule brname
	     (!' <' !eol .)+ {
	     def to_s; text_value; end
	     }
	end

	rule fcc
	     (!fieldsep .)*
	end

	rule entrycomment
	     (!eol .)*
	end

	rule emailaddress
	     (![@] [a-zA-Z0-9.-])+ [@] (![\t>,\)\n] .)+ {
	     def to_s
	     	 text_value
	     end
	     }
	end

	rule qpname
	     sqpname / dqpname
	end

	rule bpname
	     (!fieldsep .)* {
	     def to_s; text_value; end
	     }
	end

	rule sqpname
	     sq n:(!sq . / sq sq)* sq {
	     def to_s; n.text_value; end
	     }
	end

	rule dqpname
	     dq n:(!dq . / dq dq)* dq {
	     def to_s; n.text_value; end
	     }
	end

	rule dq
	     ["]
	end

	rule sq
	     [']
	end

	rule eol
	     "\n"
	end

	rule eof
	     !.
	end
end
